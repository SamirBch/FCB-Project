import {
  isServer,
  ssr
} from "./chunk-YFYO2FFS.js";
import {
  createStore,
  reconcile,
  unwrap
} from "./chunk-QAKYS4RB.js";
import {
  $TRACK,
  batch,
  createContext,
  createEffect,
  createResource,
  createSignal,
  mergeProps,
  onCleanup,
  splitProps,
  startTransition,
  untrack,
  useContext
} from "./chunk-OFYBPSL6.js";
import {
  __publicField
} from "./chunk-JVWSFFO4.js";

// node_modules/solid-start/server/responses.ts
var XSolidStartStatusCodeHeader = "x-solidstart-status-code";
var XSolidStartLocationHeader = "x-solidstart-location";
var LocationHeader = "Location";
var ContentTypeHeader = "content-type";
var XSolidStartResponseTypeHeader = "x-solidstart-response-type";
var XSolidStartContentTypeHeader = "x-solidstart-content-type";
var XSolidStartOrigin = "x-solidstart-origin";
var JSONResponseType = "application/json";
function json(data, init = {}) {
  let responseInit = init;
  if (typeof init === "number") {
    responseInit = { status: init };
  }
  let headers = new Headers(responseInit.headers);
  if (!headers.has(ContentTypeHeader)) {
    headers.set(ContentTypeHeader, "application/json; charset=utf-8");
  }
  const response = new Response(JSON.stringify(data), {
    ...responseInit,
    headers
  });
  return response;
}
function redirect(url, init = 302) {
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = { status: responseInit };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  if (url === "") {
    url = "/";
  }
  if (true) {
    if (url.startsWith(".")) {
      throw new Error("Relative URLs are not allowed in redirect");
    }
  }
  let headers = new Headers(responseInit.headers);
  headers.set(LocationHeader, url);
  const response = new Response(null, {
    ...responseInit,
    headers
  });
  return response;
}
function eventStream(request, init) {
  let stream = new ReadableStream({
    start(controller) {
      let encoder = new TextEncoder();
      let send = (event, data) => {
        controller.enqueue(encoder.encode("event: " + event + "\n"));
        controller.enqueue(encoder.encode("data: " + data + "\n\n"));
      };
      let cleanup = init(send);
      let closed = false;
      let close = () => {
        if (closed) return;
        cleanup();
        closed = true;
        request.signal.removeEventListener("abort", close);
        controller.close();
      };
      request.signal.addEventListener("abort", close);
      if (request.signal.aborted) {
        close();
        return;
      }
    }
  });
  return new Response(stream, {
    headers: { "Content-Type": "text/event-stream" }
  });
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
var redirectStatusCodes = /* @__PURE__ */ new Set([204, 301, 302, 303, 307, 308]);
function isRedirectResponse(response) {
  return response && response instanceof Response && redirectStatusCodes.has(response.status);
}

// node_modules/solid-start/data/index.ts
import { useRouteData } from "@solidjs/router";

// node_modules/solid-start/router.tsx
import {
  A as BaseA,
  Outlet as BaseOutlet,
  Routes as BaseRoutes,
  useNavigate as useBaseNavigate,
  useRouteData as useBaseRouteData,
  useSearchParams as useBaseSearchParams
} from "@solidjs/router";

// node_modules/solid-start/islands/useLocation.tsx
import { useLocation as useBaseLocation } from "@solidjs/router";
function getLocation() {
  return window.router.location();
}
function useIslandsLocation() {
  return {
    get pathname() {
      let location = getLocation();
      return location.pathname;
    },
    get hash() {
      let location = getLocation();
      return location.hash;
    },
    get search() {
      let location = getLocation();
      return location.search;
    }
  };
}
var useLocation = import.meta.env.START_ISLANDS_ROUTER && !import.meta.env.SSR ? useIslandsLocation : useBaseLocation;

// node_modules/solid-start/islands/A.tsx
function IslandsA(props) {
  const [, rest] = splitProps(props, ["state", "activeClass", "inactiveClass", "end"]);
  const location = useLocation();
  const isActive = () => {
    return props.href.startsWith("#") ? location.hash === props.href : location.pathname === props.href;
  };
  return React.createElement(
    "a",
    {
      link: true,
      ...rest,
      state: JSON.stringify(props.state),
      classList: {
        [props.inactiveClass || "inactive"]: !isActive(),
        [props.activeClass || "active"]: isActive(),
        ...rest.classList
      },
      "aria-current": isActive() ? "page" : void 0
    },
    rest.children
  );
}

// node_modules/solid-start/islands/router.ts
function useSearchParams() {
  const params = () => window.router.location().search;
  const [searchParams, setSearchParams] = createSignal(new URLSearchParams(params()));
  createEffect(() => {
    setSearchParams(new URLSearchParams(params()));
  });
  return {
    get "0"() {
      return searchParams();
    },
    get "1"() {
      return setSearchParams;
    }
  };
}

// node_modules/solid-start/root/routeLayouts.tsx
var routeLayouts = $ROUTE_LAYOUTS;

// node_modules/solid-start/server/types.tsx
var FETCH_EVENT = "$FETCH";

// node_modules/solid-start/server/ServerContext.tsx
var ServerContext = createContext({
  $type: FETCH_EVENT
});
var useRequest = () => {
  return useContext(ServerContext);
};
var useServerContext = () => {
  throw new Error("useServerContext is deprecated. Use useRequest instead.");
};

// node_modules/solid-start/islands/server-router.tsx
var RouterContext = createContext();
var useRouter = () => useContext(RouterContext);
var OutletContext = createContext();
var useOutlet = () => useContext(OutletContext);
function Outlet(props) {
  const router = useRouter();
  const parent = useOutlet();
  const depth = parent ? parent.depth : 0;
  const state = {
    depth: depth + 1,
    route: router.routes[depth]
  };
  return React.createElement(React.Fragment, null, ssr(`<!--outlet-${state.route.id}--><outlet-wrapper id="outlet-${state.route.id}">`), React.createElement(OutletContext.Provider, { value: state }, props.children), ssr(`</outlet-wrapper><!--outlet-${state.route.id}-->`));
}

// node_modules/solid-start/router.tsx
var A = import.meta.env.START_ISLANDS_ROUTER ? IslandsA : BaseA;
var Routes = import.meta.env.START_ISLANDS_ROUTER ? function IslandsRoutes(props) {
  return React.createElement(Outlet, null, React.createElement(BaseRoutes, null, props.children));
} : BaseRoutes;
var Outlet2 = import.meta.env.START_ISLANDS_ROUTER ? function HybridOutlet() {
  return React.createElement(Outlet, null, React.createElement(BaseOutlet, null));
} : BaseOutlet;
var useNavigate = import.meta.env.START_ISLANDS_ROUTER && !import.meta.env.SSR ? function IslandsUseNavigate() {
  return (to, props = {}) => window.router.navigate(to, props);
} : useBaseNavigate;
var useSearchParams2 = import.meta.env.START_ISLANDS_ROUTER && !import.meta.env.SSR ? useSearchParams : useBaseSearchParams;

// node_modules/solid-start/data/createRouteData.tsx
var resources = /* @__PURE__ */ new Set();
var promises = /* @__PURE__ */ new Map();
function createRouteData(fetcher, options = {}) {
  const navigate = useNavigate();
  const pageEvent = useRequest();
  function handleResponse2(response) {
    if (isRedirectResponse(response)) {
      startTransition(() => {
        let url = response.headers.get(LocationHeader);
        if (url && url.startsWith("/")) {
          navigate(url, {
            replace: true
          });
        } else {
          if (!isServer && url) {
            window.location.href = url;
          }
        }
      });
      if (isServer && pageEvent) {
        pageEvent.setStatusCode(response.status);
        response.headers.forEach((head, value) => {
          pageEvent.responseHeaders.set(value, head);
        });
      }
    }
  }
  const resourceFetcher = async (key) => {
    try {
      let event = pageEvent;
      if (isServer && pageEvent) {
        event = Object.freeze({
          request: pageEvent.request,
          env: pageEvent.env,
          clientAddress: pageEvent.clientAddress,
          locals: pageEvent.locals,
          $type: FETCH_EVENT,
          fetch: pageEvent.fetch
        });
      }
      let response = await fetcher.call(event, key, event);
      if (response instanceof Response) {
        if (isServer) {
          handleResponse2(response);
        } else {
          setTimeout(() => handleResponse2(response), 0);
        }
        return;
      }
      return response;
    } catch (e) {
      if (e instanceof Response) {
        if (isServer) {
          handleResponse2(e);
        } else {
          setTimeout(() => handleResponse2(e), 0);
        }
        return;
      }
      throw e;
    }
  };
  function dedupe(fetcher2) {
    return (key, info) => {
      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {
        return info.value;
      }
      if (key === true) return fetcher2(key, info);
      let promise = promises.get(key);
      if (promise) return promise;
      promise = fetcher2(key, info);
      promises.set(key, promise);
      return promise.finally(() => promises.delete(key));
    };
  }
  const [resource, { refetch }] = createResource(
    options.key || true,
    dedupe(resourceFetcher),
    {
      storage: (init) => createDeepSignal(init, options.reconcileOptions),
      ...options
    }
  );
  if (!isServer) {
    resources.add(refetch);
    onCleanup(() => resources.delete(refetch));
  }
  return resource;
}
function refetchRouteData(key) {
  if (isServer) throw new Error("Cannot refetch route data on the server.");
  return startTransition(() => {
    for (let refetch of resources) refetch(key);
  });
}
function createDeepSignal(value, options) {
  const [store, setStore] = createStore({
    value
  });
  return [
    () => store.value,
    (v) => {
      const unwrapped = untrack(() => unwrap(store.value));
      typeof v === "function" && (v = v(unwrapped));
      setStore("value", reconcile(v, options));
      return store.value;
    }
  ];
}
function partialMatch(a, b) {
  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));
}
function ensureQueryKeyArray(value) {
  return Array.isArray(value) ? value : [value];
}
function partialDeepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a.length && !b.length) return false;
  if (a && b && typeof a === "object" && typeof b === "object") {
    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]));
  }
  return false;
}

// node_modules/solid-start/data/FormError.tsx
var ServerError = class extends Error {
  constructor(message, { status, stack } = {}) {
    super(message);
    __publicField(this, "status");
    this.name = "ServerError";
    this.status = status || 400;
    if (stack) {
      this.stack = stack;
    }
  }
};
var FormError = class extends ServerError {
  constructor(message, {
    fieldErrors = {},
    form,
    fields,
    stack
  } = {}) {
    super(message, { stack });
    __publicField(this, "formError");
    __publicField(this, "fields");
    __publicField(this, "fieldErrors");
    this.formError = message;
    this.name = "FormError";
    this.fields = fields || Object.fromEntries(typeof form !== "undefined" ? form.entries() : []) || {};
    this.fieldErrors = fieldErrors;
  }
};

// node_modules/solid-start/data/Form.tsx
var FormImpl = (_props) => {
  let [props, rest] = splitProps(
    mergeProps(
      {
        reloadDocument: false,
        replace: false,
        method: "post",
        action: "/",
        encType: "application/x-www-form-urlencoded"
      },
      _props
    ),
    [
      "reloadDocument",
      "replace",
      "method",
      "action",
      "encType",
      "onSubmission",
      "onSubmit",
      "children",
      "ref"
    ]
  );
  let submit = useSubmitImpl((submission) => {
    props.onSubmission && props.onSubmission(submission);
  });
  let formMethod = props.method.toLowerCase() === "get" ? "get" : "post";
  let clickedButtonRef = null;
  let form = null;
  createEffect(() => {
    if (!form) return;
    function handleClick(event) {
      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement)) return;
      let submitButton = event.target.closest(
        "button,input[type=submit]"
      );
      if (submitButton && submitButton.type === "submit") {
        clickedButtonRef = submitButton;
      }
    }
    form.addEventListener("click", handleClick);
    onCleanup(() => {
      form && form.removeEventListener("click", handleClick);
    });
  }, []);
  return React.createElement(
    "form",
    {
      ref: (f) => {
        form = f;
        if (typeof props.ref === "function") props.ref(f);
      },
      method: formMethod,
      action: _props.action,
      enctype: props.encType,
      onSubmit: props.reloadDocument ? void 0 : (event) => {
        props.onSubmit && props.onSubmit(event);
        if (event.defaultPrevented) return;
        event.preventDefault();
        submit(clickedButtonRef || event.currentTarget, {
          method: props.method,
          replace: props.replace
        });
        clickedButtonRef = null;
      },
      ...rest
    },
    props.children
  );
};
function useSubmitImpl(onSubmission) {
  return (target, options = {}) => {
    let method;
    let action;
    let encType;
    let formData;
    if (isFormElement(target)) {
      let submissionTrigger = options.submissionTrigger;
      method = options.method || target.method;
      action = options.action || target.action;
      encType = options.encType || target.enctype;
      formData = new FormData(target);
      if (submissionTrigger && submissionTrigger.name) {
        formData.append(submissionTrigger.name, submissionTrigger.value);
      }
    } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
      let form = target.form;
      if (form == null) {
        throw new Error(`Cannot submit a <button> without a <form>`);
      }
      method = options.method || target.getAttribute("formmethod") || form.method;
      action = options.action || target.getAttribute("formaction") || form.action;
      encType = options.encType || target.getAttribute("formenctype") || form.enctype;
      formData = new FormData(form);
      if (target.name) {
        formData.set(target.name, target.value);
      }
    } else {
      if (isHtmlElement(target)) {
        throw new Error(
          `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
        );
      }
      method = options.method || "get";
      action = options.action || "/";
      encType = options.encType || "application/x-www-form-urlencoded";
      if (target instanceof FormData) {
        formData = target;
      } else {
        formData = new FormData();
        if (target instanceof URLSearchParams) {
          for (let [name, value] of target) {
            formData.append(name, value);
          }
        } else if (target != null) {
          for (let name of Object.keys(target)) {
            formData.append(name, target[name]);
          }
        }
      }
    }
    let { protocol, host } = window.location;
    let url = new URL(isButtonElement(action) ? "/" : action, `${protocol}//${host}`);
    if (method.toLowerCase() === "get") {
      for (let [name, value] of formData) {
        if (typeof value === "string") {
          url.searchParams.append(name, value);
        } else {
          throw new Error(`Cannot submit binary form data using GET`);
        }
      }
    }
    let submission = {
      formData,
      action: url.pathname + url.search,
      method: method.toUpperCase(),
      encType
    };
    onSubmission(submission);
  };
}
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}

// node_modules/solid-start/data/createRouteAction.tsx
function createRouteAction(fn, options = {}) {
  let init = checkFlash(fn);
  const [input, setInput] = createSignal(init.input);
  const [result, setResult] = createSignal(init.result);
  const navigate = useNavigate();
  const event = useRequest();
  let count = 0;
  function submit(variables) {
    let p;
    if (import.meta.env.START_ISLANDS && fn.url) {
      p = fetch(fn.url, {
        method: "POST",
        body: variables instanceof FormData ? variables : JSON.stringify([variables, { $type: "fetch_event" }]),
        headers: {
          ...variables instanceof FormData ? {} : { "Content-Type": "application/json" },
          [XSolidStartOrigin]: "client",
          "x-solid-referrer": window.router.location().pathname,
          "x-solid-mutation": "true"
        }
      });
    } else {
      p = fn(variables, event);
    }
    const reqId = ++count;
    batch(() => {
      setResult(void 0);
      setInput(() => variables);
    });
    return p.then(async (data) => {
      if (reqId === count) {
        if (data instanceof Response) {
          await handleResponse(data, navigate, options);
        } else await handleRefetch(data, options);
        if (!data || isRedirectResponse(data)) setInput(void 0);
        else setResult({ data });
      }
      return data;
    }).catch(async (e) => {
      if (reqId === count) {
        if (e instanceof Response) {
          await handleResponse(e, navigate, options);
        }
        if (!isRedirectResponse(e)) {
          setResult({ error: e });
        } else setInput(void 0);
      }
      return void 0;
    });
  }
  submit.url = fn.url;
  submit.Form = (props) => {
    let url = fn.url;
    return React.createElement(
      FormImpl,
      {
        ...props,
        action: url,
        onSubmission: (submission) => {
          submit(submission.formData);
        }
      },
      props.children
    );
  };
  return [
    {
      get pending() {
        return !!input() && !result();
      },
      get input() {
        return input();
      },
      get result() {
        var _a;
        return (_a = result()) == null ? void 0 : _a.data;
      },
      get error() {
        var _a;
        return (_a = result()) == null ? void 0 : _a.error;
      },
      clear() {
        batch(() => {
          setInput(void 0);
          setResult(void 0);
        });
      },
      retry() {
        const variables = input();
        if (!variables) throw new Error("No submission to retry");
        submit(variables);
      }
    },
    submit
  ];
}
function createRouteMultiAction(fn, options = {}) {
  let init = checkFlash(fn);
  const [submissions, setSubmissions] = createSignal(
    init.input ? [createSubmission(init.input)[0]] : []
  );
  const navigate = useNavigate();
  const event = useRequest();
  function createSubmission(variables) {
    let submission;
    const [result, setResult] = createSignal();
    return [
      submission = {
        input: variables,
        get result() {
          var _a;
          return (_a = result()) == null ? void 0 : _a.data;
        },
        get error() {
          var _a;
          return (_a = result()) == null ? void 0 : _a.error;
        },
        clear() {
          setSubmissions((v) => v.filter((i) => i.input !== variables));
        },
        retry() {
          setResult(void 0);
          return event && handleSubmit(fn(variables, event));
        }
      },
      handleSubmit
    ];
    function handleSubmit(p) {
      p.then(async (data) => {
        if (data instanceof Response) {
          await handleResponse(data, navigate, options);
          data = data.body;
        } else await handleRefetch(data, options);
        data ? setResult({ data }) : submission.clear();
        return data;
      }).catch(async (e) => {
        if (e instanceof Response) {
          await handleResponse(e, navigate, options);
        } else await handleRefetch(e, options);
        if (!isRedirectResponse(e)) {
          setResult({ error: e });
        } else submission.clear();
      });
      return p;
    }
  }
  function submit(variables) {
    if (!event) {
      throw new Error("submit was called without an event");
    }
    const [submission, handleSubmit] = createSubmission(variables);
    setSubmissions((s) => [...s, submission]);
    return handleSubmit(fn(variables, event));
  }
  submit.url = fn.url;
  submit.Form = (props) => {
    let url = fn.url;
    return React.createElement(
      FormImpl,
      {
        ...props,
        action: url,
        onSubmission: (submission) => {
          submit(submission.formData);
        }
      },
      props.children
    );
  };
  return [
    new Proxy([], {
      get(_, property) {
        if (property === $TRACK) return submissions();
        if (property === "pending") return submissions().filter((sub) => !sub.result);
        return submissions()[property];
      }
    }),
    submit
  ];
}
function handleRefetch(response, options = {}) {
  return refetchRouteData(
    typeof options.invalidate === "function" ? options.invalidate(response) : options.invalidate
  );
}
async function handleResponse(response, navigate, options) {
  if (response instanceof Response && isRedirectResponse(response)) {
    const locationUrl = response.headers.get("Location") || "/";
    if (locationUrl.startsWith("http")) {
      window.location.href = locationUrl;
    } else {
      navigate(locationUrl);
    }
    return handleRefetch(response, options);
  } else if (response instanceof Response && response.headers.get("Content-type") === "text/solid-diff") {
    let i = await window.router.update(await response.text());
    if (i) {
      window.router.push(response.headers.get("x-solid-location") ?? "/", {});
    }
  }
  return handleRefetch(response, options);
}
function checkFlash(fn) {
  const [params] = useSearchParams2();
  let param = params.form ? JSON.parse(params.form) : null;
  if (!param || param.url !== fn.url) {
    return {};
  }
  const input = new Map(param.entries);
  return {
    result: {
      error: param.error ? new FormError(param.error.message, {
        fieldErrors: param.error.fieldErrors,
        stack: param.error.stack,
        form: param.error.form,
        fields: param.error.fields
      }) : void 0
    },
    input
  };
}

// node_modules/solid-start/server/server-functions/browser.ts
async function parseResponse(request, response) {
  const contentType = response.headers.get(XSolidStartContentTypeHeader) || response.headers.get(ContentTypeHeader) || "";
  if (contentType.includes("json")) {
    return await response.json();
  } else if (contentType.includes("text")) {
    return await response.text();
  } else if (contentType.includes("server-error")) {
    const data = await response.json();
    return new ServerError(data.error.message, {
      stack: data.error.stack,
      status: response.status
    });
  } else if (contentType.includes("form-error")) {
    const data = await response.json();
    return new FormError(data.error.message, {
      fieldErrors: data.error.fieldErrors,
      fields: data.error.fields,
      stack: data.error.stack
    });
  } else if (contentType.includes("error")) {
    const data = await response.json();
    const error = new Error(data.error.message);
    if (data.error.stack) {
      error.stack = data.error.stack;
    }
    return error;
  } else if (contentType.includes("response")) {
    if (response.status === 204 && response.headers.get(LocationHeader)) {
      return redirect(response.headers.get(LocationHeader) ?? "/");
    }
    return response;
  } else {
    if (response.status === 200) {
      const text = await response.text();
      try {
        return JSON.parse(text);
      } catch {
      }
    }
    if (response.status === 204 && response.headers.get(LocationHeader)) {
      return redirect(response.headers.get(LocationHeader) ?? "/");
    }
    return response;
  }
}
var server$ = (_fn) => {
  throw new Error("Should be compiled away");
};
function createRequestInit(init, ...args) {
  let body, headers = {
    [XSolidStartOrigin]: "client",
    ...init.headers ?? {}
  };
  if (args[0] instanceof FormData) {
    body = args[0];
  } else {
    if (Array.isArray(args) && args.length > 2) {
      let secondArg = args[1];
      if (typeof secondArg === "object" && "value" in secondArg && "refetching" in secondArg) {
        secondArg.value = void 0;
      }
    }
    body = JSON.stringify(args, (key, value) => {
      if (value instanceof Headers) {
        return {
          $type: "headers",
          values: [...value.entries()]
        };
      }
      if (value instanceof Request) {
        return {
          $type: "request",
          url: value.url,
          method: value.method,
          headers: value.headers
        };
      }
      return value;
    });
    headers[ContentTypeHeader] = JSONResponseType;
  }
  return {
    method: "POST",
    body,
    ...init,
    headers: new Headers({
      ...headers
    })
  };
}
server$.createFetcher = (route, serverResource) => {
  let fetcher = function(...args) {
    const requestInit = serverResource ? createRequestInit({}, args[0]) : createRequestInit({}, ...args);
    return server$.exec(route, requestInit);
  };
  fetcher.url = route;
  fetcher.fetch = (init, ...args) => {
    const requestInit = createRequestInit(init, ...args);
    server$.exec(route, requestInit);
  };
  return fetcher;
};
server$.exec = async function(route, init) {
  const request = new Request(new URL(route, window.location.href).href, init);
  const response = await fetch(request);
  if (response.headers.get(XSolidStartResponseTypeHeader) === "throw") {
    throw await parseResponse(request, response);
  } else {
    return await parseResponse(request, response);
  }
};
server$.fetch = async function(route, init) {
  if (route instanceof URL || route.startsWith("http")) {
    return await fetch(route, init);
  }
  const request = new Request(new URL(route, window.location.href).href, init);
  return await fetch(request);
};

// node_modules/solid-start/server/components/HttpHeader.tsx
function HttpHeader(props) {
  const pageContext = useRequest();
  if (isServer) {
    if (props.append) {
      pageContext.responseHeaders.append(props.name, props.value);
    } else {
      pageContext.responseHeaders.set(props.name, props.value);
    }
  }
  onCleanup(() => {
    if (isServer) {
      const value = pageContext.responseHeaders.get(props.name);
      if (value) {
        const values = value.split(", ");
        const index = values.indexOf(props.value);
        index !== -1 && values.splice(index, 1);
        if (values.length) pageContext.responseHeaders.set(props.name, values.join(", "));
        else pageContext.responseHeaders.delete(props.name);
      }
    }
  });
  return null;
}

// node_modules/solid-start/server/components/HttpStatusCode.tsx
function HttpStatusCode(props) {
  const context = useRequest();
  if (isServer) {
    context.setStatusCode(props.code);
  }
  onCleanup(() => {
    if (isServer) {
      context.setStatusCode(200);
    }
  });
  return null;
}

// node_modules/solid-start/server/data.ts
var createServerData$ = createRouteData;
var createServerAction$ = createRouteAction;
var createServerMultiAction$ = createRouteMultiAction;

// node_modules/solid-start/server/browser.ts
var isServerFunctionRequest = () => {
  throw new Error("isServerFunctionRequest is not supported on the browser");
};
export {
  ContentTypeHeader,
  FETCH_EVENT,
  HttpHeader,
  HttpStatusCode,
  JSONResponseType,
  LocationHeader,
  ServerContext,
  ServerError,
  XSolidStartContentTypeHeader,
  XSolidStartLocationHeader,
  XSolidStartOrigin,
  XSolidStartResponseTypeHeader,
  XSolidStartStatusCodeHeader,
  createServerAction$,
  createServerData$,
  createServerMultiAction$,
  server$ as default,
  eventStream,
  isRedirectResponse,
  isResponse,
  isServerFunctionRequest,
  json,
  redirect,
  useRequest,
  useServerContext
};
/*! Bundled license information:

solid-start/data/Form.tsx:
  (*!
   * Original code by Remix Sofware Inc
   * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details
   * 
   * Credits to the Remix team for the Form implementation:
   * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865
   *)
*/
//# sourceMappingURL=solid-start_server.js.map
