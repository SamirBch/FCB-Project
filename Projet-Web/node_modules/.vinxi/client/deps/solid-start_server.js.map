{
  "version": 3,
  "sources": ["../../../solid-start/server/responses.ts", "../../../solid-start/data/index.ts", "../../../solid-start/router.tsx", "../../../solid-start/islands/useLocation.tsx", "../../../solid-start/islands/A.tsx", "../../../solid-start/islands/router.ts", "../../../solid-start/root/routeLayouts.tsx", "../../../solid-start/server/types.tsx", "../../../solid-start/server/ServerContext.tsx", "../../../solid-start/islands/server-router.tsx", "../../../solid-start/data/createRouteData.tsx", "../../../solid-start/data/FormError.tsx", "../../../solid-start/data/Form.tsx", "../../../solid-start/data/createRouteAction.tsx", "../../../solid-start/server/server-functions/browser.ts", "../../../solid-start/server/components/HttpHeader.tsx", "../../../solid-start/server/components/HttpStatusCode.tsx", "../../../solid-start/server/data.ts", "../../../solid-start/server/browser.ts"],
  "sourcesContent": ["export const XSolidStartStatusCodeHeader = \"x-solidstart-status-code\";\nexport const XSolidStartLocationHeader = \"x-solidstart-location\";\nexport const LocationHeader = \"Location\";\nexport const ContentTypeHeader = \"content-type\";\nexport const XSolidStartResponseTypeHeader = \"x-solidstart-response-type\";\nexport const XSolidStartContentTypeHeader = \"x-solidstart-content-type\";\nexport const XSolidStartOrigin = \"x-solidstart-origin\";\nexport const JSONResponseType = \"application/json\";\n\n/**\n * A JSON response. Converts `data` to JSON and sets the `Content-Type` header.\n */\nexport function json<Data>(data: Data, init: number | ResponseInit = {}): Response {\n  let responseInit: any = init;\n  if (typeof init === \"number\") {\n    responseInit = { status: init };\n  }\n\n  let headers = new Headers(responseInit.headers);\n\n  if (!headers.has(ContentTypeHeader)) {\n    headers.set(ContentTypeHeader, \"application/json; charset=utf-8\");\n  }\n\n  const response = new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers\n  });\n\n  return response;\n}\n\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport function redirect(url: string, init: number | ResponseInit = 302): Response {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n\n  if (url === \"\") {\n    url = \"/\";\n  }\n\n  if (process.env.NODE_ENV === \"development\") {\n    if (url.startsWith(\".\")) {\n      throw new Error(\"Relative URLs are not allowed in redirect\");\n    }\n  }\n\n  let headers = new Headers(responseInit.headers);\n  headers.set(LocationHeader, url);\n\n  const response = new Response(null, {\n    ...responseInit,\n    headers: headers\n  });\n\n  return response;\n}\n\nexport function eventStream(\n  request: Request,\n  init: (send: (event: string, data: any) => void) => () => void\n) {\n  let stream = new ReadableStream({\n    start(controller) {\n      let encoder = new TextEncoder();\n      let send = (event: string, data: any) => {\n        controller.enqueue(encoder.encode(\"event: \" + event + \"\\n\"));\n        controller.enqueue(encoder.encode(\"data: \" + data + \"\\n\" + \"\\n\"));\n      };\n      let cleanup = init(send);\n      let closed = false;\n      let close = () => {\n        if (closed) return;\n        cleanup();\n        closed = true;\n        request.signal.removeEventListener(\"abort\", close);\n        controller.close();\n      };\n      request.signal.addEventListener(\"abort\", close);\n      if (request.signal.aborted) {\n        close();\n        return;\n      }\n    }\n  });\n  return new Response(stream, {\n    headers: { \"Content-Type\": \"text/event-stream\" }\n  });\n}\n\nexport function isResponse(value: any): value is Response {\n  return (\n    value != null &&\n    typeof value.status === \"number\" &&\n    typeof value.statusText === \"string\" &&\n    typeof value.headers === \"object\" &&\n    typeof value.body !== \"undefined\"\n  );\n}\n\nconst redirectStatusCodes = new Set([204, 301, 302, 303, 307, 308]);\n\nexport function isRedirectResponse(response: Response | any): boolean {\n  return response && response instanceof Response && redirectStatusCodes.has(response.status);\n}\n", "export { useRouteData } from \"@solidjs/router\";\nexport { createRouteAction, createRouteMultiAction } from \"./createRouteAction\";\nexport { createRouteData, refetchRouteData } from \"./createRouteData\";\nexport type { FormAction, FormMethod, FormProps, SubmitOptions } from \"./Form\";\nexport { FormError, ServerError } from \"./FormError\";\n\n", "import {\n  A as BaseA,\n  Location,\n  NavigateOptions,\n  Navigator,\n  Outlet as BaseOutlet,\n  RouteDataFunc,\n  Routes as BaseRoutes,\n  useNavigate as useBaseNavigate,\n  useRouteData as useBaseRouteData,\n  useSearchParams as useBaseSearchParams\n} from \"@solidjs/router\";\nimport { JSX } from \"solid-js\";\nimport IslandsA from \"./islands/A\";\nimport { LocationEntry, useSearchParams as useIslandsSearchParams } from \"./islands/router\";\nimport { Outlet as IslandsOutlet } from \"./islands/server-router\";\n\nexport type RouteParams<T extends string> = Record<T, string>;\n\nexport type RouteDataArgs<T extends keyof StartRoutes = \"$\"> = {\n  data: StartRoutes[T][\"data\"];\n  params: RouteParams<StartRoutes[T][\"params\"]>;\n  location: Location;\n  navigate: Navigator;\n};\n\nconst A = import.meta.env.START_ISLANDS_ROUTER ? IslandsA : BaseA;\n\nconst Routes = /* @__PURE__ */ import.meta.env.START_ISLANDS_ROUTER\n  ? /* @__PURE__ */ function IslandsRoutes(props: { children: JSX.Element }) {\n      return (\n        <IslandsOutlet>\n          <BaseRoutes>{props.children}</BaseRoutes>\n        </IslandsOutlet>\n      );\n    }\n  : /* @__PURE__ */ BaseRoutes;\n\nconst Outlet = /* @__PURE__ */ import.meta.env.START_ISLANDS_ROUTER\n  ? /* @__PURE__ */ function HybridOutlet() {\n      return (\n        <IslandsOutlet>\n          <BaseOutlet />\n        </IslandsOutlet>\n      );\n    }\n  : /* @__PURE__ */ BaseOutlet;\n\nconst useNavigate =\n  import.meta.env.START_ISLANDS_ROUTER && !import.meta.env.SSR\n    ? (function IslandsUseNavigate() {\n        return (to, props: Partial<NavigateOptions> = {}) =>\n          window.router.navigate(to as string, props);\n      } as typeof useBaseNavigate)\n    : useBaseNavigate;\n\nconst useSearchParams =\n  /* @__PURE__ */ import.meta.env.START_ISLANDS_ROUTER && !import.meta.env.SSR\n    ? useIslandsSearchParams\n    : /* @__PURE__ */ useBaseSearchParams;\n\ndeclare global {\n  interface Window {\n    router: {\n      navigate: (to: string, options?: Partial<NavigateOptions>) => Promise<boolean>;\n      push: (to: string | URL, options: Partial<NavigateOptions>) => void;\n      update: (body: string) => Promise<boolean>;\n      router: EventTarget;\n      location: () => LocationEntry;\n    };\n  }\n\n  interface StartRoutes {\n    $: {\n      params: any;\n      data: any;\n    };\n  }\n\n  interface Route {\n    \"/notes/[note]\": \"/notes/[note]\";\n  }\n}\n\nexport function useRouteData<T extends keyof StartRoutes>(): ReturnType<StartRoutes[T][\"data\"]>;\nexport function useRouteData<T extends (...args: any[]) => any>(): T extends RouteDataFunc<infer _, infer R> ? R : ReturnType<T>;\nexport function useRouteData<T extends keyof StartRoutes>(): ReturnType<StartRoutes[T][\"data\"]> {\n  // @ts-ignore\n  return useBaseRouteData<T>();\n}\n\nexport { useLocation } from \"./islands/useLocation\";\nexport { A, Outlet, Routes, useNavigate, useSearchParams };\n\n", "import { useLocation as useBaseLocation, type Location } from \"@solidjs/router\";\n\nfunction getLocation() {\n  return window.router.location();\n}\n\nfunction useIslandsLocation() {\n  return {\n    get pathname() {\n      let location = getLocation();\n      return location.pathname;\n    },\n    get hash() {\n      let location = getLocation();\n      return location.hash;\n    },\n    get search() {\n      let location = getLocation();\n      return location.search;\n    }\n  } as Location;\n}\n\nexport const useLocation =\n  import.meta.env.START_ISLANDS_ROUTER && !import.meta.env.SSR\n    ? useIslandsLocation\n    : useBaseLocation;\n", "\"use client\";\nimport type { A as BaseA } from \"@solidjs/router\";\nimport { ComponentProps, splitProps } from \"solid-js\";\nimport { useLocation } from \"./useLocation\";\n\nexport default function IslandsA(props: ComponentProps<typeof BaseA>) {\n  const [, rest] = splitProps(props, [\"state\", \"activeClass\", \"inactiveClass\", \"end\"]);\n  const location = useLocation();\n  const isActive = () => {\n    return props.href.startsWith(\"#\")\n      ? location.hash === props.href\n      : location.pathname === props.href;\n  };\n\n  return (\n    <a\n      link\n      {...rest}\n      state={JSON.stringify(props.state)}\n      classList={{\n        [props.inactiveClass || \"inactive\"]: !isActive(),\n        [props.activeClass || \"active\"]: isActive(),\n        ...rest.classList\n      }}\n      aria-current={isActive() ? \"page\" : undefined}\n    >\n      {rest.children}\n    </a>\n  );\n}\n", "import type { Location, Params } from \"@solidjs/router\";\nimport { createEffect, createSignal } from \"solid-js\";\n\nexport interface LocationEntry {\n  path: string;\n  state: any;\n  pathname: string;\n  search: string;\n  hash: string;\n}\n\nexport function useSearchParams<T extends Params>() {\n  const params = () => window.router.location().search;\n  const [searchParams, setSearchParams] = createSignal(new URLSearchParams(params()));\n\n  createEffect(() => {\n    setSearchParams(new URLSearchParams(params()));\n  });\n\n  return {\n    get \"0\"() {\n      return searchParams();\n    },\n    get \"1\"() { return setSearchParams }\n  } as unknown as [T, (params: T) => void];\n}\n\nexport default function mountRouter() {\n  if (import.meta.env.START_ISLANDS_ROUTER) {\n    _$DEBUG(\"mounting islands router\");\n\n    const basePath = \"/\";\n    let [currentLocation, setCurrentLocation] = createSignal<Location & LocationEntry>(\n      getLocation()\n    );\n\n    let eventTarget = new EventTarget();\n\n    function getLocation(): Location & LocationEntry {\n      const { pathname, search, hash } = window.location;\n      return {\n        path: pathname + search + hash,\n        state: history.state,\n        pathname,\n        search,\n        hash,\n        query: {},\n        key: \"\"\n      };\n    }\n\n    function pushRoute(to: string | URL, options: Partial<NavigateOptions>) {\n      let u = new URL(to, window.location.origin);\n      if (options.replace) {\n        history.replaceState(options.state, \"\", u);\n      } else {\n        history.pushState(options.state, \"\", u);\n      }\n      setCurrentLocation(getLocation());\n    }\n\n    async function handleAnchorClick(evt: MouseEvent) {\n      if (\n        evt.defaultPrevented ||\n        evt.button !== 0 ||\n        evt.metaKey ||\n        evt.altKey ||\n        evt.ctrlKey ||\n        evt.shiftKey\n      )\n        return;\n\n      const a = evt\n        .composedPath()\n        .find(el => el instanceof Node && el.nodeName.toUpperCase() === \"A\") as\n        | HTMLAnchorElement\n        | undefined;\n\n      if (!a || !a.hasAttribute(\"link\")) return;\n\n      const href = a.href;\n      const target = a.target;\n      if (target || (!href && !a.hasAttribute(\"state\"))) return;\n\n      const rel = (a.getAttribute(\"rel\") || \"\").split(/\\s+/);\n      if (a.hasAttribute(\"download\") || (rel && rel.includes(\"external\"))) return;\n\n      const url = new URL(href);\n      if (\n        url.origin !== window.location.origin ||\n        (basePath && url.pathname && !url.pathname.toLowerCase().startsWith(basePath.toLowerCase()))\n      )\n        return;\n\n      const prevLocation = getLocation();\n\n      const to = url.pathname + url.search + url.hash;\n      const state = a.getAttribute(\"state\");\n\n      if (url.pathname === prevLocation.pathname && url.search === prevLocation.search) {\n        if (url.hash !== prevLocation.hash) {\n          window.location.hash = url.hash;\n          setCurrentLocation(getLocation());\n        }\n      }\n\n      evt.preventDefault();\n\n      const options = {\n        resolve: false,\n        replace: a.hasAttribute(\"replace\"),\n        scroll: !a.hasAttribute(\"noscroll\"),\n        state: state && JSON.parse(state)\n      };\n\n      await doNavigate(to, options);\n      pushRoute(to, options);\n    }\n\n    interface NavigateOptions {\n      resolve?: boolean;\n      replace?: boolean;\n      scroll?: boolean;\n      state?: any;\n    }\n\n    async function handlePopState(evt: PopStateEvent) {\n      const { pathname, search, hash, state } = getLocation();\n      const to = pathname + search + hash;\n      if (await doNavigate(to)) {\n        setCurrentLocation(getLocation());\n      }\n    }\n\n    async function doNavigate(to: string, options: Partial<NavigateOptions> = {}) {\n      router.router.dispatchEvent(new CustomEvent(\"navigation-start\", { detail: to }));\n      const response = await fetch(to, {\n        method: \"POST\",\n        headers: {\n          \"x-solid-referrer\": currentLocation().pathname\n        }\n      });\n\n      if (!response.ok) {\n        console.error(`Navigation failed: ${response.status} ${response.statusText}`);\n        router.router.dispatchEvent(new CustomEvent(\"navigation-error\", { detail: to }));\n        return false;\n      }\n\n      let body = await response.text();\n      let updated = await update(body);\n      if (updated) {\n        router.router.dispatchEvent(new CustomEvent(\"navigation-end\", { detail: to }));\n        return true;\n      }\n\n      router.router.dispatchEvent(new CustomEvent(\"navigation-error\", { detail: to }));\n      return false;\n    }\n\n    async function navigate(to: string, options: Partial<NavigateOptions> = {}) {\n      if (await doNavigate(to)) {\n        pushRoute(to, options);\n        return true;\n      }\n      return false;\n    }\n\n    let router = {\n      navigate,\n      push: pushRoute,\n      update,\n      router: eventTarget,\n      location: currentLocation\n    };\n\n    window.router = router;\n\n    document.addEventListener(\"click\", handleAnchorClick);\n    window.addEventListener(\"popstate\", handlePopState);\n    _$DEBUG(\"mounted islands router\");\n  }\n}\n\nasync function update(body: string) {\n  let assets: [[string, string][], [string, string][]] | undefined;\n  if (body.charAt(0) === \"a\") {\n    const assetsIndex = body.indexOf(\";\");\n    assets = JSON.parse(body.substring(\"assets=\".length, assetsIndex));\n    body = body.substring(assetsIndex + 1);\n  }\n\n  if (body.charAt(0) === \"o\") {\n    const splitIndex = body.indexOf(\"=\");\n    const meta = body.substring(0, splitIndex);\n    const content = body.substring(splitIndex + 1);\n\n    if (meta) {\n      if (assets && assets.length) {\n        assets[0].forEach(([assetType, href]) => {\n          if (!document.querySelector(`link[href=\"${href}\"]`)) {\n            let link = document.createElement(\"link\");\n            link.rel = assetType === \"style\" ? \"stylesheet\" : \"modulepreload\";\n            link.href = href;\n            document.head.appendChild(link);\n          }\n        });\n\n        assets[1].forEach(([assetType, href]) => {\n          let el = document.querySelector(`link[href=\"${href}\"]`);\n          if (el) {\n            document.head.removeChild(el);\n          }\n        });\n      }\n\n      const [prev, next] = meta.split(\":\");\n      const outletEl = document.getElementById(prev);\n      if (outletEl) {\n        let doc = document.implementation.createHTMLDocument();\n        doc.write(`<outlet-wrapper id=\"${next}\">`);\n        doc.write(content);\n        doc.write(\"</outlet-wrapper>\");\n\n        if (import.meta.env.START_ISLANDS) {\n          await window._$HY.morph(outletEl, doc.body.firstChild as HTMLElement);\n        }\n        return true;\n      } else {\n        console.warn(`No outlet element with id ${prev}`);\n      }\n    } else {\n      console.warn(`No meta data in response`);\n    }\n  }\n  return false;\n}\n", "// @ts-expect-error\nvar routeLayouts = $ROUTE_LAYOUTS;\n\nvar layouts = routeLayouts as {\n  [key: string]: {\n    layouts: string[];\n    id: string;\n  };\n};\n\nexport { layouts as routeLayouts };\n", "import { Server } from \"http\";\n\nexport type ManifestEntry = {\n  type: string;\n  href: string;\n};\n\nexport const FETCH_EVENT = \"$FETCH\";\n\nexport type ContextMatches = {\n  originalPath: string;\n  pattern: string;\n  path: string;\n  params: unknown;\n};\n\ntype TagDescription = {\n  tag: string;\n  props: Record<string, unknown>;\n};\n\ntype RouterContext = {\n  // router matches;\n  matches: ContextMatches[][];\n  // redirected url\n  url: string;\n\n  // server route fragments\n  replaceOutletId: string;\n  newOutletId: string;\n  partial: boolean;\n  nextRoute: any;\n  prevRoute: any;\n};\n\nexport type IslandManifest = {\n  type: \"island\";\n  script: ManifestEntry;\n  assets: ManifestEntry[];\n};\n\nexport type RouteManifest = {\n  type: \"route\";\n  script: ManifestEntry;\n  assets: ManifestEntry[];\n};\n\nexport type StartManifest = {\n  [key: string]: RouteManifest | IslandManifest;\n  \"entry-client\": RouteManifest;\n  \"index.html\": RouteManifest;\n};\n\ndeclare global {\n  interface Env {\n    /**\n     * BE CAREFUL WHILE USING. AVAILABLE IN PRODUCTION ONLY.\n     */\n    manifest?: StartManifest;\n    /**\n     * BE CAREFUL WHILE USING. AVAILABLE IN PRODUCTION ONLY.\n     */\n    getStaticHTML?(path: string): Promise<Response>;\n    /**\n     * BE CAREFUL WHILE USING. AVAILABLE IN DEVELOPMENT ONLY.\n     */\n    __dev?: {\n      /**\n       * @warning\n       */\n      collectStyles?: (matches: string[]) => Promise<Record<string, string>>;\n      manifest?: [{ path: string; componentPath: string; id: string }];\n    };\n  }\n}\n\nexport interface LocalsExt {}\n\nexport interface FetchEvent {\n  request: Request;\n  httpServer?: Server;\n  env: Env;\n  fetch(url: string, init?: RequestInit): Promise<Response>;\n  clientAddress: string;\n  locals: Record<string, unknown> & LocalsExt;\n}\n\nexport interface ServerFunctionEvent extends FetchEvent {\n  $type: typeof FETCH_EVENT;\n}\n\nexport interface PageEvent extends FetchEvent {\n  prevUrl: string | null;\n  responseHeaders: Headers;\n  routerContext: RouterContext & { assets: ManifestEntry[] };\n  tags: TagDescription[];\n  setStatusCode(code: number): void;\n  getStatusCode(): number;\n  $type: typeof FETCH_EVENT;\n  $islands: Set<string>;\n  mutation: boolean;\n}\n", "import { FETCH_EVENT, PageEvent } from \"./types\";\n\nimport { createContext, useContext } from \"solid-js\";\n\nexport const ServerContext = /*#__PURE__*/ createContext<PageEvent>({\n  $type: FETCH_EVENT\n} as any);\n\nexport const useRequest = () => {\n  return useContext(ServerContext)!;\n};\n\nexport const useServerContext = () => {\n  throw new Error(\"useServerContext is deprecated. Use useRequest instead.\");\n};\n", "import { createContext, JSX, useContext } from \"solid-js\";\nimport { ssr } from \"solid-js/web\";\nimport { getAssetsFromManifest } from \"../root/assets\";\nimport { useRequest } from \"../server/ServerContext\";\nexport interface RouteDefinition {\n  path: string;\n  component?: () => JSX.Element;\n  children?: RouteDefinition | RouteDefinition[];\n  data?: any;\n}\n\nexport type Params = Record<string, string>;\n\nexport interface PathMatch {\n  params: Params;\n  path: string;\n}\n\nexport interface MatchedRoute {\n  id: string;\n  originalPath: string;\n  pattern: string;\n  component: (props: any) => JSX.Element;\n  children?: RouteDefinition | RouteDefinition[];\n  match: PathMatch;\n  data?: any;\n  shared: boolean;\n}\n\nexport interface Branch {\n  routes: MatchedRoute[];\n  score: number;\n}\n\nconst hasSchemeRegex = /*#__PURE__*/ /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /*#__PURE__*/ /^\\/+|\\/+$|\\s+/g;\n\nfunction normalize(path: string) {\n  const s = path.replace(trimPathRegex, \"\");\n  return s ? (s.startsWith(\"?\") ? s : \"/\" + s) : \"\";\n}\n\nexport function resolvePath(base: string, path: string, from?: string): string | undefined {\n  if (hasSchemeRegex.test(path)) {\n    return undefined;\n  }\n  const basePath = normalize(base);\n  const fromPath = from && normalize(from);\n  let result = \"\";\n  if (!fromPath || path.charAt(0) === \"/\") {\n    result = basePath;\n  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n    result = basePath + fromPath;\n  } else {\n    result = fromPath;\n  }\n  return result + normalize(path) || \"/\";\n}\n\nexport function joinPaths(from: string, to: string): string {\n  return normalize(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalize(to);\n}\n\nexport function matchPath(path: string, location: string, partial?: boolean): PathMatch | null {\n  const [pattern, splat] = path.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  const len = segments.length;\n  const { pathname } = new URL(location, \"http://localhost\");\n  const locSegments = pathname.split(\"/\").filter(Boolean);\n  const lenDiff = locSegments.length - len;\n  if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\n    return null;\n  }\n\n  const match: PathMatch = {\n    path: len ? \"\" : \"/\",\n    params: {}\n  };\n\n  for (let i = 0; i < len; i++) {\n    const segment = segments[i];\n    const locSegment = locSegments[i];\n\n    if (segment[0] === \":\") {\n      match.params[segment.slice(1)] = locSegment;\n    } else if (segment.localeCompare(locSegment, undefined, { sensitivity: \"base\" }) !== 0) {\n      return null;\n    }\n    match.path += `/${locSegment}`;\n  }\n\n  if (splat) {\n    match.params[splat] = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n  }\n\n  return match;\n}\n\nexport function scoreRoute(route: MatchedRoute): number {\n  const [pattern, splat] = route.pattern.split(\"/*\", 2);\n  const segments = pattern.split(\"/\").filter(Boolean);\n  return segments.reduce(\n    (score, segment) => score + (segment.startsWith(\":\") ? 2 : 3),\n    segments.length - (splat === undefined ? 0 : 1)\n  );\n}\n\nexport function createMatchedRoute(\n  routeDef: RouteDefinition,\n  base: string,\n  id: string,\n  location: string\n): MatchedRoute | null {\n  if (!routeDef || typeof routeDef !== \"object\" || !routeDef.hasOwnProperty(\"path\")) {\n    return null;\n  }\n\n  const { path: originalPath, component = Outlet, children, data } = routeDef;\n  const isLeaf = !children || !Array.isArray(children) || !children.length;\n  const path = joinPaths(base, originalPath);\n  const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n\n  const match = matchPath(pattern, location, !isLeaf);\n  if (!match) {\n    return null;\n  }\n\n  return {\n    id,\n    originalPath,\n    pattern,\n    component,\n    children,\n    data,\n    match,\n    shared: false\n  };\n}\n\nexport function getMatchedBranch(\n  routeDef: RouteDefinition | RouteDefinition[],\n  location: string,\n  stack: MatchedRoute[] = [],\n  branches: Branch[] = []\n): Branch | null {\n  const routeDefs = Array.isArray(routeDef) ? routeDef : [routeDef];\n\n  for (let i = 0, len = routeDefs.length; i < len; i++) {\n    const def = routeDefs[i];\n    const parent = stack[stack.length - 1];\n    const route = createMatchedRoute(\n      def,\n      parent ? parent.pattern : \"/\",\n      parent ? `${parent.id}.${i}` : \"\" + i,\n      location\n    );\n\n    if (route) {\n      stack.push(route);\n\n      if (def.children) {\n        getMatchedBranch(def.children, location, stack, branches);\n      } else {\n        const score = scoreRoute(route);\n        if (!branches.length || score > branches[0].score) {\n          branches[0] = {\n            routes: [...stack],\n            score\n          };\n        }\n      }\n\n      stack.pop();\n    }\n  }\n\n  return branches[0] || null;\n}\n\nexport interface RouterContextState {\n  routes: MatchedRoute[];\n  location: string;\n}\n\nexport const RouterContext = /*#__PURE__*/ createContext<RouterContextState>();\n\nexport const useRouter = () => useContext(RouterContext)!;\n\nexport interface OutletContextState {\n  depth: number;\n  route: MatchedRoute;\n}\n\nexport const OutletContext = /*#__PURE__*/ createContext<OutletContextState>();\n\nexport const useOutlet = () => useContext(OutletContext);\n\nexport const useRouteParams = () => {\n  const outlet = useOutlet()!;\n  return () => outlet.route.match.params;\n};\n\nexport interface RouterProps {\n  location: string;\n  prevLocation: string | null;\n  routes: RouteDefinition | RouteDefinition[];\n  children: JSX.Element;\n  out?: any;\n}\n\nexport function Router(props: RouterProps) {\n  const context = useRequest();\n  const next = getMatchedBranch(props.routes, props.location);\n  if (!next || !next.routes.length) {\n    return [];\n  }\n\n  const nextRoutes = next.routes;\n\n  const prev =\n    !context.mutation && props.prevLocation\n      ? getMatchedBranch(props.routes, props.prevLocation)\n      : null;\n  if (prev) {\n    const prevRoutes = prev.routes;\n\n    if (import.meta.env.PROD) {\n      let nextAssets = getAssetsFromManifest(context, [\n        nextRoutes.map(r => ({\n          ...r,\n          ...r.match\n        }))\n      ]);\n\n      let prevAssets = getAssetsFromManifest(context, [\n        prevRoutes.map(r => ({\n          ...r,\n          ...r.match\n        }))\n      ]);\n\n      const set = new Set();\n      prevAssets.forEach(a => {\n        set.add(a.href);\n      });\n\n      let assetsToAdd: [string, string][] = [];\n\n      let assetsToRemove: Record<string, [string, string]> = {};\n\n      nextAssets.forEach(a => {\n        if (!set.has(a.href) && (a.type === \"script\" || a.type === \"style\")) {\n          assetsToRemove[a.href] = [a.type, a.href];\n        } else {\n          set.delete(a.href);\n        }\n      });\n\n      [...set.entries()].forEach(a => {\n        let prev = prevAssets.find(p => p.href === a[1]);\n        if (prev) {\n          assetsToAdd.push([prev.type, prev.href]);\n        }\n      });\n\n      props.out.assets = [Object.values(assetsToRemove), assetsToAdd];\n    }\n\n    for (let i = 0, len = nextRoutes.length; i < len; i++) {\n      const nextRoute = nextRoutes[i];\n      const prevRoute = prevRoutes[i];\n      if (\n        prevRoute &&\n        nextRoute.id === prevRoute.id &&\n        nextRoute.match.path === prevRoute.match.path\n      ) {\n        if (JSON.stringify(nextRoute.match.params) === JSON.stringify(prevRoute.match.params)) {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n        } else {\n          props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n          props.out.newOutletId = `outlet-${nextRoute.id}`;\n          props.out.prevRoute = prevRoute;\n          props.out.nextRoute = nextRoute;\n        }\n        // Routes are shared\n      } else if (prevRoute && nextRoute) {\n        props.out.replaceOutletId = `outlet-${prevRoute.id}`;\n        props.out.prevRoute = prevRoute;\n        props.out.newOutletId = `outlet-${nextRoute.id}`;\n        props.out.nextRoute = nextRoute;\n      }\n    }\n  }\n\n  const state = {\n    routes: nextRoutes,\n    location: props.location,\n    out: props.out\n  };\n\n  // if (props.out.prevRoute) {\n  //   props.out.partial = true;\n  //   return (\n  //     <RouterContext.Provider value={state}>\n  //       <OutletContext.Provider\n  //         value={{ depth: nextRoutes.indexOf(props.out.nextRoute) + 1, route: props.out.nextRoute }}\n  //       >\n  //         <NoHydration>\n  //           <Suspense>\n  //             <Routes>\n  //               <Route\n  //                 path={props.out.nextRoute.pattern}\n  //                 component={props.out.nextRoute.component}\n  //                 data={props.out.nextRoute.data}\n  //                 children={props.out.nextRoute.children}\n  //               />\n  //             </Routes>\n  //           </Suspense>\n  //         </NoHydration>\n  //       </OutletContext.Provider>\n  //     </RouterContext.Provider>\n  //   );\n  // }\n\n  return <RouterContext.Provider value={state}>{props.children}</RouterContext.Provider>;\n}\n\nexport function Outlet(props: { children: JSX.Element }) {\n  const router = useRouter();\n  const parent = useOutlet();\n  const depth = parent ? parent.depth : 0;\n\n  const state = {\n    depth: depth + 1,\n    route: router.routes[depth]\n  };\n\n  return (\n    <>\n      {ssr(`<!--outlet-${state.route.id}--><outlet-wrapper id=\"outlet-${state.route.id}\">`)}\n      <OutletContext.Provider value={state}>{props.children}</OutletContext.Provider>\n      {ssr(`</outlet-wrapper><!--outlet-${state.route.id}-->`)}\n    </>\n  );\n}\n", "import type {\n  Accessor, Resource,\n  ResourceFetcher, ResourceFetcherInfo, ResourceOptions, Setter\n} from \"solid-js\";\nimport {\n  createResource,\n  onCleanup,\n  startTransition, untrack\n} from \"solid-js\";\nimport type { ReconcileOptions } from \"solid-js/store\";\nimport { createStore, reconcile, unwrap } from \"solid-js/store\";\nimport { isServer } from \"solid-js/web\";\nimport { useNavigate } from \"../router\";\nimport { isRedirectResponse, LocationHeader } from \"../server/responses\";\nimport { useRequest } from \"../server/ServerContext\";\nimport { FETCH_EVENT, ServerFunctionEvent } from \"../server/types\";\n\ninterface RouteDataEvent extends ServerFunctionEvent {}\n\ntype RouteDataSource<S> = S | false | null | undefined | (() => S | false | null | undefined);\n\ntype RouteDataFetcher<S, T> = (source: S, event: RouteDataEvent) => T | Promise<T>;\n\ntype RouteDataOptions<T, S> = ResourceOptions<T> & {\n  key?: RouteDataSource<S>;\n  reconcileOptions?: ReconcileOptions;\n};\n\nconst resources = new Set<(k: any) => void>();\nconst promises = new Map<any, Promise<any>>();\n\nexport function createRouteData<T, S = true>(\n  fetcher: RouteDataFetcher<S, T>,\n  options?: RouteDataOptions<undefined, S>\n): Resource<T | undefined>;\nexport function createRouteData<T, S = true>(\n  fetcher: RouteDataFetcher<S, T>,\n  options: RouteDataOptions<T, S>\n): Resource<T>;\nexport function createRouteData<T, S = true>(\n  fetcher: RouteDataFetcher<S, T>,\n  options: RouteDataOptions<T, S> | RouteDataOptions<undefined, S> = {}\n): Resource<T> | Resource<T | undefined> {\n  const navigate = useNavigate();\n  const pageEvent = useRequest();\n\n  function handleResponse(response: Response) {\n    if (isRedirectResponse(response)) {\n      startTransition(() => {\n        let url = response.headers.get(LocationHeader);\n        if (url && url.startsWith(\"/\")) {\n          navigate(url, {\n            replace: true\n          });\n        } else {\n          if (!isServer && url) {\n            window.location.href = url;\n          }\n        }\n      });\n      if (isServer && pageEvent) {\n        pageEvent.setStatusCode(response.status);\n        response.headers.forEach((head, value) => {\n          pageEvent.responseHeaders.set(value, head);\n        });\n      }\n    }\n  }\n\n  const resourceFetcher: ResourceFetcher<S, T> = async (key: S) => {\n    try {\n      let event = pageEvent as RouteDataEvent;\n      if (isServer && pageEvent) {\n        event = Object.freeze({\n          request: pageEvent.request,\n          env: pageEvent.env,\n          clientAddress: pageEvent.clientAddress,\n          locals: pageEvent.locals,\n          $type: FETCH_EVENT,\n          fetch: pageEvent.fetch\n        });\n      }\n\n      let response = await (fetcher as any).call(event, key, event);\n      if (response instanceof Response) {\n        if (isServer) {\n          handleResponse(response);\n        } else {\n          setTimeout(() => handleResponse(response), 0);\n        }\n        return;\n      }\n      return response;\n    } catch (e: any | Error) {\n      if (e instanceof Response) {\n        if (isServer) {\n          handleResponse(e);\n        } else {\n          setTimeout(() => handleResponse(e as Response), 0);\n        }\n        return;\n      }\n      throw e;\n    }\n  };\n\n  function dedupe(fetcher: ResourceFetcher<S, T>): ResourceFetcher<S, T> {\n    return (key: S, info: ResourceFetcherInfo<T>) => {\n      if (info.refetching && info.refetching !== true && !partialMatch(key, info.refetching) && info.value) {\n        return info.value;\n      }\n\n      if ((key as unknown as boolean) === true) return fetcher(key, info);\n\n      let promise = promises.get(key);\n      if (promise) return promise;\n      promise = fetcher(key, info) as Promise<T>;\n      promises.set(key, promise);\n      return promise.finally(() => promises.delete(key));\n    };\n  }\n\n  const [resource, { refetch }] = createResource<T, S>(\n    (options.key || true) as RouteDataSource<S>,\n    dedupe(resourceFetcher),\n    {\n      storage: (init: T | undefined) => createDeepSignal(init, options.reconcileOptions),\n      ...options\n    } as any\n  );\n\n  if (!isServer) {\n    resources.add(refetch);\n    onCleanup(() => resources.delete(refetch));\n  }\n\n  return resource;\n}\n\nexport function refetchRouteData(key?: string | any[] | void) {\n  if (isServer) throw new Error(\"Cannot refetch route data on the server.\");\n  return startTransition(() => {\n    for (let refetch of resources) refetch(key);\n  });\n}\n\nfunction createDeepSignal<T>(value: T | undefined, options?: ReconcileOptions) {\n  const [store, setStore] = createStore({\n    value\n  });\n  return [\n    () => store.value,\n    (v: T) => {\n      const unwrapped = untrack(() => unwrap(store.value));\n      typeof v === \"function\" && (v = v(unwrapped));\n      setStore(\"value\", reconcile(v, options));\n      return store.value;\n    }\n  ] as [Accessor<T | null>, Setter<T | null>];\n}\n\n/* React Query key matching  https://github.com/tannerlinsley/react-query */\nfunction partialMatch(a: any, b: any) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\n\nfunction ensureQueryKeyArray<V extends any | any[], R = V extends [] ? V : [V]>(value: V): R {\n  return (Array.isArray(value) ? value : [value]) as R;\n}\n\n/**\n * Checks if `b` partially matches with `a`.\n */\nfunction partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a.length && !b.length) return false;\n\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n", "export class ServerError extends Error {\n  status: number;\n  constructor(message: string, { status, stack }: { status?: number; stack?: string } = {}) {\n    super(message);\n    this.name = \"ServerError\";\n    this.status = status || 400\n    if (stack) {\n      this.stack = stack;\n    }\n  }\n}\n\nexport class FormError extends ServerError {\n  formError?: string;\n  fields?: {};\n  fieldErrors?: { [key: string]: string };\n  constructor(\n    message: string,\n    {\n      fieldErrors = {},\n      form,\n      fields,\n      stack\n    }: { fieldErrors?: {}; form?: FormData; fields?: {}; stack?: string } = {}\n  ) {\n    super(message, { stack });\n    this.formError = message;\n    this.name = \"FormError\";\n    this.fields =\n      fields || Object.fromEntries(typeof form !== \"undefined\" ? form.entries() : []) || {};\n    this.fieldErrors = fieldErrors;\n  }\n}\n", "/*!\n * Original code by Remix Sofware Inc\n * MIT Licensed, Copyright(c) 2021 Remix software Inc, see LICENSE.remix.md for details\n * \n * Credits to the Remix team for the Form implementation:\n * https://github.com/remix-run/remix/blob/main/packages/remix-react/components.tsx#L865\n */\nimport { ComponentProps, createEffect, mergeProps, onCleanup, splitProps } from \"solid-js\";\n\nexport interface FormAction<Data> {\n  action: string;\n  method: string;\n  formData: Data;\n  encType: string;\n}\n\nexport { FormError } from \"./FormError\";\nexport { FormImpl as Form };\n\ntype FormEncType = \"application/x-www-form-urlencoded\" | \"multipart/form-data\";\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  encType?: FormEncType;\n\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\n\nexport interface SubmitFunction {\n  (\n    /**\n     * Specifies the `<form>` to be submitted to the server, a specific\n     * `<button>` or `<input type=\"submit\">` to use to submit the form, or some\n     * arbitrary data to submit.\n     *\n     * Note: When using a `<button>` its `name` and `value` will also be\n     * included in the form data that is submitted.\n     */\n    target:\n      | HTMLFormElement\n      | HTMLButtonElement\n      | HTMLInputElement\n      | FormData\n      | URLSearchParams\n      | { [name: string]: string }\n      | null,\n\n    /**\n     * Options that override the `<form>`'s own attributes. Required when\n     * submitting arbitrary data without a backing `<form>`.\n     */\n    options?: SubmitOptions\n  ): void;\n}\n\nexport type FormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\n\nexport interface FormProps extends Omit<ComponentProps<\"form\">, \"method\" | \"onSubmit\"> {\n  /**\n   * The HTTP verb to use when the form is submit. Supports \"get\", \"post\",\n   * \"put\", \"delete\", \"patch\".\n   *\n   * Note: If JavaScript is disabled, you'll need to implement your own \"method\n   * override\" to support more than just GET and POST.\n   */\n  method?: FormMethod;\n\n  /**\n   * Normal `<form action>` but supports React Router's relative paths.\n   */\n  action?: string;\n\n  /**\n   * Normal `<form encType>`.\n   *\n   * Note: Remix only supports `application/x-www-form-urlencoded` right now\n   * but will soon support `multipart/form-data` as well.\n   */\n  // encType?: FormEncType;\n  /**\n   * Forces a full document navigation instead of a fetch.\n   */\n  reloadDocument?: boolean;\n\n  /**\n   * Replaces the current entry in the browser history stack when the form\n   * navigates. Use this if you don't want the user to be able to click \"back\"\n   * to the page with the form on it.\n   */\n  replace?: boolean;\n\n  onSubmit?: (event: SubmitEvent) => void;\n\n  /**\n   * A function to call when the form is submitted. If you call\n   * `event.preventDefault()` then this form will not be called.\n   */\n  onSubmission?: (submission: FormAction<FormData>) => void;\n}\n/**\n * A Remix-aware `<form>`. It behaves like a normal form except that the\n * interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\n// export let Form = React.forwardRef<HTMLFormElement, FormProps>((props, ref) => {\n//   return <FormImpl {...props} ref={ref} />;\n// });\ninterface FormImplProps extends FormProps {\n  onSubmmsion?: (submission: FormAction<FormData>) => void;\n}\n\nexport let FormImpl = (_props: FormImplProps) => {\n  let [props, rest] = splitProps(\n    mergeProps(\n      {\n        reloadDocument: false,\n        replace: false,\n        method: \"post\" as FormMethod,\n        action: \"/\",\n        encType: \"application/x-www-form-urlencoded\" as FormEncType\n      },\n      _props\n    ),\n    [\n      \"reloadDocument\",\n      \"replace\",\n      \"method\",\n      \"action\",\n      \"encType\",\n      \"onSubmission\",\n      \"onSubmit\",\n      \"children\",\n      \"ref\"\n    ]\n  );\n  let submit = useSubmitImpl(submission => {\n    props.onSubmission && props.onSubmission(submission);\n  });\n  let formMethod: FormMethod = props.method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  // let formAction = useFormAction(props.action, formMethod);\n  // let formRef = React.useRef<HTMLFormElement>();\n  // let ref = useComposedRefs(forwardedRef, formRef);\n  // When calling `submit` on the form element itself, we don't get data from\n  // the button that submitted the event. For example:\n  //\n  //   <Form>\n  //     <button name=\"something\" value=\"whatever\">Submit</button>\n  //   </Form>\n  //\n  // formData.get(\"something\") should be \"whatever\", but we don't get that\n  // unless we call submit on the clicked button itself.\n  //\n  // To figure out which button triggered the submit, we'll attach a click\n  // event listener to the form. The click event is always triggered before\n  // the submit event (even when submitting via keyboard when focused on\n  // another form field, yeeeeet) so we should have access to that button's\n  // data for use in the submit handler.\n  let clickedButtonRef: HTMLButtonElement | HTMLInputElement | null = null;\n  let form: HTMLFormElement | null = null;\n\n  createEffect(() => {\n    if (!form) return;\n\n    function handleClick(event: MouseEvent) {\n      if (!(event.target instanceof HTMLElement || event.target instanceof SVGElement)) return;\n      let submitButton = event.target.closest<HTMLButtonElement | HTMLInputElement>(\n        \"button,input[type=submit]\"\n      );\n\n      if (submitButton && submitButton.type === \"submit\") {\n        clickedButtonRef = submitButton;\n      }\n    }\n\n    form.addEventListener(\"click\", handleClick);\n    onCleanup(() => {\n      form && form.removeEventListener(\"click\", handleClick);\n    });\n  }, []);\n  return (\n    <form\n      ref={f => {\n        form = f;\n        if (typeof props.ref === \"function\") props.ref(f);\n      }}\n      method={formMethod}\n      action={_props.action}\n      enctype={props.encType}\n      // encType={encType}\n      onSubmit={\n        props.reloadDocument\n          ? undefined\n          : event => {\n              props.onSubmit && props.onSubmit(event);\n              if (event.defaultPrevented) return;\n              event.preventDefault();\n              submit(clickedButtonRef || event.currentTarget, {\n                method: props.method,\n                replace: props.replace\n              });\n              clickedButtonRef = null;\n            }\n      }\n      {...rest}\n    >\n      {props.children}\n    </form>\n  );\n};\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: FormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   *\n   * Note: It is assumed the path is already resolved. If you need to resolve a\n   * relative path, use `useFormAction`.\n   */\n  action?: string;\n\n  /**\n   * The action URL used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  // encType?: FormEncType;\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n}\n\nexport function useSubmitImpl(\n  onSubmission: (sub: FormAction<FormData>) => void\n): SubmitFunction {\n  return (target, options = {}) => {\n    let method: string;\n    let action: string;\n    let encType: string;\n    let formData: FormData;\n\n    if (isFormElement(target)) {\n      let submissionTrigger: HTMLButtonElement | HTMLInputElement = (options as any)\n        .submissionTrigger;\n\n      method = options.method || target.method;\n      action = options.action || target.action;\n      encType = options.encType || target.enctype;\n      formData = new FormData(target);\n\n      if (submissionTrigger && submissionTrigger.name) {\n        formData.append(submissionTrigger.name, submissionTrigger.value);\n      }\n    } else if (\n      isButtonElement(target) ||\n      (isInputElement(target) && (target.type === \"submit\" || target.type === \"image\"))\n    ) {\n      let form = target.form;\n\n      if (form == null) {\n        throw new Error(`Cannot submit a <button> without a <form>`);\n      }\n\n      // <button>/<input type=\"submit\"> may override attributes of <form>\n      method = options.method || target.getAttribute(\"formmethod\") || form.method;\n      action = options.action || target.getAttribute(\"formaction\") || form.action;\n      encType = options.encType || target.getAttribute(\"formenctype\") || form.enctype;\n      formData = new FormData(form);\n\n      // Include name + value from a <button>\n      if (target.name) {\n        formData.set(target.name, target.value);\n      }\n    } else {\n      if (isHtmlElement(target)) {\n        throw new Error(\n          `Cannot submit element that is not <form>, <button>, or ` + `<input type=\"submit|image\">`\n        );\n      }\n\n      method = options.method || \"get\";\n      action = options.action || \"/\";\n      encType = options.encType || \"application/x-www-form-urlencoded\";\n\n      if (target instanceof FormData) {\n        formData = target;\n      } else {\n        formData = new FormData();\n\n        if (target instanceof URLSearchParams) {\n          for (let [name, value] of target) {\n            formData.append(name, value);\n          }\n        } else if (target != null) {\n          for (let name of Object.keys(target)) {\n            formData.append(name, target[name]);\n          }\n        }\n      }\n    }\n\n    let { protocol, host } = window.location;\n    let url = new URL(isButtonElement(action) ? \"/\" : action, `${protocol}//${host}`);\n\n    if (method.toLowerCase() === \"get\") {\n      for (let [name, value] of formData) {\n        if (typeof value === \"string\") {\n          url.searchParams.append(name, value);\n        } else {\n          throw new Error(`Cannot submit binary form data using GET`);\n        }\n      }\n    }\n\n    let submission: FormAction<FormData> = {\n      formData,\n      action: url.pathname + url.search,\n      method: method.toUpperCase(),\n      encType\n    };\n\n    onSubmission(submission);\n  };\n}\nfunction isHtmlElement(object: any): object is HTMLElement {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object: any): object is HTMLButtonElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object: any): object is HTMLFormElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object: any): object is HTMLInputElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n", "import { type Navigator } from \"@solidjs/router\";\nimport { $TRACK, batch, createSignal, type ParentComponent } from \"solid-js\";\nimport { useNavigate, useSearchParams } from \"../router\";\nimport { isRedirectResponse, XSolidStartOrigin } from \"../server/responses\";\nimport type { ServerFunction } from \"../server/server-functions/types\";\nimport { useRequest } from \"../server/ServerContext\";\nimport type { ServerFunctionEvent } from \"../server/types\";\nimport { refetchRouteData } from \"./createRouteData\";\nimport { FormError, FormImpl, type FormProps } from \"./Form\";\n\ninterface ActionEvent extends ServerFunctionEvent {}\nexport interface Submission<T, U> {\n  input: T;\n  result?: U;\n  error?: any;\n  clear: () => void;\n  retry: () => void;\n}\n\nexport type RouteAction<T, U> = [\n  {\n    pending: boolean;\n    input?: T;\n    result?: U;\n    error?: any;\n    clear: () => void;\n    retry: () => void;\n  },\n  ((vars: T) => Promise<U | undefined>) & {\n    Form: ParentComponent<FormProps | T>;\n    url: string;\n  }\n];\nexport type RouteMultiAction<T, U> = [\n  Submission<T, U>[] & { pending: Submission<T, U>[] },\n  ((vars: T) => Promise<U | undefined>) & {\n    Form: ParentComponent<FormProps | T>;\n    url: string;\n  }\n];\n\nexport type Invalidate = ((r: Response) => string | any[] | void) | string | any[];\n\nexport function createRouteAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteAction<T, U>;\nexport function createRouteAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [input, setInput] = createSignal<T | undefined>(init.input);\n  const [result, setResult] = createSignal<{ data?: U; error?: any } | undefined>(init.result);\n  const navigate = useNavigate();\n  const event = useRequest();\n  let count = 0;\n  function submit(variables: T): Promise<U> {\n    let p: Promise<U>;\n    if (import.meta.env.START_ISLANDS && (fn as ServerFunction<any, any>).url) {\n      p = fetch((fn as ServerFunction<any, any>).url, {\n        method: \"POST\",\n        body:\n          variables instanceof FormData\n            ? variables\n            : JSON.stringify([variables, { $type: \"fetch_event\" }]),\n        headers: {\n          ...(variables instanceof FormData ? {} : { \"Content-Type\": \"application/json\" }),\n          [XSolidStartOrigin]: \"client\",\n          \"x-solid-referrer\": window.router.location().pathname,\n          \"x-solid-mutation\": \"true\"\n        }\n      }) as unknown as Promise<U>;\n    } else {\n      p = fn(variables, event);\n    }\n    const reqId = ++count;\n    batch(() => {\n      setResult(undefined);\n      setInput(() => variables);\n    });\n    return p\n      .then(async data => {\n        if (reqId === count) {\n          if (data instanceof Response) {\n            await handleResponse(data, navigate, options);\n          } else await handleRefetch(data as unknown as any[], options);\n          if (!data || isRedirectResponse(data)) setInput(undefined);\n          else setResult({ data });\n        }\n        return data;\n      })\n      .catch(async (e: Response | Error) => {\n        if (reqId === count) {\n          if (e instanceof Response) {\n            await handleResponse(e, navigate, options);\n          }\n          if (!isRedirectResponse(e)) {\n            setResult({ error: e });\n          } else setInput(undefined);\n        }\n        return undefined;\n      }) as Promise<U>;\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: Omit<FormProps, \"action\" | \"onSubmission\">) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as ParentComponent<FormProps | T>;\n\n  return [\n    {\n      get pending() {\n        return !!input() && !result();\n      },\n      get input() {\n        return input();\n      },\n      get result() {\n        return result()?.data;\n      },\n      get error(): any {\n        return result()?.error;\n      },\n      clear() {\n        batch(() => {\n          setInput(undefined);\n          setResult(undefined);\n        });\n      },\n      retry() {\n        const variables = input();\n        if (!variables) throw new Error(\"No submission to retry\");\n        submit(variables);\n      }\n    },\n    submit\n  ];\n}\n\ntype ActionOptions = {\n  invalidate?: ((r: Response) => string | any[] | void) | string | any[];\n};\n\nexport function createRouteMultiAction<T = void, U = void>(\n  fn: (arg1: void, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options?: { invalidate?: Invalidate }\n): RouteMultiAction<T, U>;\nexport function createRouteMultiAction<T, U = void>(\n  fn: (args: T, event: ActionEvent) => Promise<U>,\n  options: { invalidate?: Invalidate } = {}\n): RouteMultiAction<T, U> {\n  let init: { result?: { data?: U; error?: any }; input?: T } = checkFlash<T>(fn);\n  const [submissions, setSubmissions] = createSignal<Submission<T, U>[]>(\n    init.input ? [createSubmission(init.input)[0]] : []\n  );\n  const navigate = useNavigate();\n  const event = useRequest();\n\n  function createSubmission(variables: T) {\n    let submission: {\n      input: T,\n      readonly result: U | undefined,\n      readonly error: Error | undefined,\n      clear(): void,\n      retry(): void\n    };\n    const [result, setResult] = createSignal<{ data?: U; error?: any }>();\n    return [\n      (submission = {\n        input: variables,\n        get result() {\n          return result()?.data;\n        },\n        get error() {\n          return result()?.error;\n        },\n        clear() {\n          setSubmissions(v => v.filter(i => i.input !== variables));\n        },\n        retry() {\n          setResult(undefined);\n          return event && handleSubmit(fn(variables, event));\n        }\n      }),\n      handleSubmit\n    ] as const;\n    function handleSubmit(p: Promise<Response & { body: U } | U>): Promise<U> {\n      p.then(async data => {\n        if (data instanceof Response) {\n          await handleResponse(data, navigate, options);\n          data = data.body;\n        } else await handleRefetch(data as unknown as any[], options);\n        data ? setResult({ data }) : submission.clear();\n\n        return data;\n      }).catch(async e => {\n        if (e instanceof Response) {\n          await handleResponse(e, navigate, options);\n        } else await handleRefetch(e, options);\n        if (!isRedirectResponse(e)) {\n          setResult({ error: e });\n        } else submission.clear();\n      });\n      return p as Promise<U>;\n    }\n  }\n  function submit(variables: T) {\n    if (!event) {\n      throw new Error('submit was called without an event');\n    }\n    const [submission, handleSubmit] = createSubmission(variables);\n    setSubmissions(s => [...s, submission]);\n    return handleSubmit(fn(variables, event));\n  }\n  submit.url = (fn as any).url;\n  submit.Form = ((props: FormProps) => {\n    let url = (fn as any).url;\n    return (\n      <FormImpl\n        {...props}\n        action={url}\n        onSubmission={submission => {\n          submit(submission.formData as any);\n        }}\n      >\n        {props.children}\n      </FormImpl>\n    );\n  }) as ParentComponent<FormProps | T>;\n\n  return [\n    new Proxy<Submission<T, U>[] & { pending: Submission<T, U>[] }>([] as any, {\n      get(_, property) {\n        if (property === $TRACK) return submissions();\n        if (property === \"pending\") return submissions().filter(sub => !sub.result);\n        return submissions()[property as keyof typeof submissions];\n      }\n    }),\n    submit\n  ];\n}\n\nfunction handleRefetch(response: Response | string | any[], options: { invalidate?: Invalidate } = {}) {\n  return refetchRouteData(\n    typeof options.invalidate === \"function\" ? options.invalidate(response as Response) : options.invalidate\n  );\n}\n\nasync function handleResponse(response: Response, navigate: Navigator, options?: { invalidate?: Invalidate }) {\n  if (response instanceof Response && isRedirectResponse(response)) {\n    const locationUrl = response.headers.get(\"Location\") || \"/\";\n    if (locationUrl.startsWith(\"http\")) {\n      window.location.href = locationUrl;\n    } else {\n      navigate(locationUrl);\n    }\n    return handleRefetch(response, options);\n  } else if (\n    response instanceof Response &&\n    response.headers.get(\"Content-type\") === \"text/solid-diff\"\n  ) {\n    let i = await window.router.update(await response.text());\n    if (i) {\n      window.router.push(response.headers.get(\"x-solid-location\") ?? \"/\", {});\n    }\n  }\n\n  return handleRefetch(response, options);\n}\n\nfunction checkFlash<T>(fn: any) {\n  const [params] = useSearchParams();\n\n  let param = params.form ? JSON.parse(params.form) : null;\n  if (!param || param.url !== (fn as any).url) {\n    return {};\n  }\n\n  const input = new Map(param.entries);\n  return {\n    result: {\n      error: param.error\n        ? new FormError(param.error.message, {\n            fieldErrors: param.error.fieldErrors,\n            stack: param.error.stack,\n            form: param.error.form,\n            fields: param.error.fields\n          })\n        : undefined\n    },\n    input: input as unknown as T\n  };\n}\n", "import {\n  ContentTypeHeader,\n  JSONResponseType,\n  LocationHeader,\n  redirect,\n  XSolidStartContentTypeHeader,\n  XSolidStartOrigin,\n  XSolidStartResponseTypeHeader\n} from \"../responses\";\n\nimport { FormError } from \"../../data\";\nimport { ServerError } from \"../../data/FormError\";\nimport { CreateServerFunction, ServerFunction } from \"./types\";\n\nexport async function parseResponse(request: Request, response: Response) {\n  const contentType =\n    response.headers.get(XSolidStartContentTypeHeader) ||\n    response.headers.get(ContentTypeHeader) ||\n    \"\";\n  if (contentType.includes(\"json\")) {\n    return await response.json();\n  } else if (contentType.includes(\"text\")) {\n    return await response.text();\n  } else if (contentType.includes(\"server-error\")) {\n    const data = await response.json();\n    return new ServerError(data.error.message, {\n      stack: data.error.stack,\n      status: response.status\n    });\n  } else if (contentType.includes(\"form-error\")) {\n    const data = await response.json();\n    return new FormError(data.error.message, {\n      fieldErrors: data.error.fieldErrors,\n      fields: data.error.fields,\n      stack: data.error.stack\n    });\n  } else if (contentType.includes(\"error\")) {\n    const data = await response.json();\n    const error = new Error(data.error.message);\n    if (data.error.stack) {\n      error.stack = data.error.stack;\n    }\n    return error;\n  } else if (contentType.includes(\"response\")) {\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader) ?? \"/\");\n    }\n    return response;\n  } else {\n    if (response.status === 200) {\n      const text = await response.text();\n      try {\n        return JSON.parse(text);\n      } catch {}\n    }\n    if (response.status === 204 && response.headers.get(LocationHeader)) {\n      return redirect(response.headers.get(LocationHeader) ?? \"/\");\n    }\n    return response;\n  }\n}\n\nexport const server$ = ((_fn: any) => {\n  throw new Error(\"Should be compiled away\");\n}) as unknown as CreateServerFunction;\n\nfunction createRequestInit(init: RequestInit, ...args: any[]): RequestInit {\n  // parsing args when a request is made from the browser for a server module\n  // FormData\n  // Request\n  // Headers\n  //\n  let body,\n    headers: Record<string, string> = {\n      [XSolidStartOrigin]: \"client\",\n      ...((init.headers ?? {}) as Record<string, string>)\n    };\n\n  if (args[0] instanceof FormData) {\n    body = args[0];\n  } else {\n    // special case for when server is used as fetcher for createResource\n    // we set {}.value to undefined. This keeps the createResource API intact as the type\n    // of this object is { value: T | undefined; refetching: boolean }\n    // So the user is expected to check value for undefined, and by setting it as undefined\n    // we can match user expectations that they dont have access to previous data on\n    // the server\n    if (Array.isArray(args) && args.length > 2) {\n      let secondArg = args[1];\n      if (typeof secondArg === \"object\" && \"value\" in secondArg && \"refetching\" in secondArg) {\n        secondArg.value = undefined;\n      }\n    }\n    body = JSON.stringify(args, (key, value) => {\n      if (value instanceof Headers) {\n        return {\n          $type: \"headers\",\n          values: [...value.entries()]\n        };\n      }\n      if (value instanceof Request) {\n        return {\n          $type: \"request\",\n          url: value.url,\n          method: value.method,\n          headers: value.headers\n        };\n      }\n      return value;\n    });\n    headers[ContentTypeHeader] = JSONResponseType;\n  }\n\n  return {\n    method: \"POST\",\n    body: body,\n    ...init,\n    headers: new Headers({\n      ...headers\n    })\n  };\n}\n\ntype ServerCall = (route: string, init: RequestInit) => Promise<Response>;\n\nserver$.createFetcher = (route, serverResource) => {\n  let fetcher: any = function (this: Request, ...args: any[]) {\n    const requestInit = serverResource ? createRequestInit({}, args[0]) : createRequestInit({}, ...args);\n    // request body: json, formData, or string\n    return server$.exec(route, requestInit);\n  };\n\n  fetcher.url = route;\n  fetcher.fetch = (init: RequestInit, ...args: any[]) => {\n    const requestInit = createRequestInit(init, ...args);\n    (server$.exec as ServerCall)(route, requestInit);\n  }\n  return fetcher as ServerFunction<any, any>;\n};\n\nserver$.exec = async function (route: string, init: RequestInit) {\n  const request = new Request(new URL(route, window.location.href).href, init);\n\n  const response = await fetch(request);\n\n  // // throws response, error, form error, json object, string\n  if (response.headers.get(XSolidStartResponseTypeHeader) === \"throw\") {\n    throw await parseResponse(request, response);\n  } else {\n    return await parseResponse(request, response);\n  }\n} as any;\n\n// used to fetch from an API route on the server or client, without falling into\n// fetch problems on the server\nserver$.fetch = async function (route: string | URL, init: RequestInit) {\n  if (route instanceof URL || route.startsWith(\"http\")) {\n    return await fetch(route, init);\n  }\n  const request = new Request(new URL(route, window.location.href).href, init);\n  return await fetch(request);\n};\n", "import { onCleanup } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { useRequest } from \"../ServerContext\";\n\nexport function HttpHeader(props: { name: string; value: string, append?: boolean  }) {\n  const pageContext = useRequest();\n\n  if (isServer) {\n    if (props.append) {\n      pageContext!.responseHeaders.append(props.name, props.value);\n    } else {\n      pageContext!.responseHeaders.set(props.name, props.value);\n    }\n  }\n\n  onCleanup(() => {\n    if (isServer) {\n      const value = pageContext!.responseHeaders.get(props.name);\n      if (value) {\n        const values = value.split(\", \");\n        const index = values.indexOf(props.value);\n        index !== -1 && values.splice(index, 1);\n        if (values.length) pageContext!.responseHeaders.set(props.name, values.join(\", \"));\n        else pageContext!.responseHeaders.delete(props.name);\n      }\n    }\n  });\n\n  return null;\n}\n", "import { onCleanup } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { useRequest } from \"../ServerContext\";\n\nexport function HttpStatusCode(props: { code: number }) {\n  const context = useRequest();\n\n  if (isServer) {\n    context!.setStatusCode(props.code);\n  }\n\n  onCleanup(() => {\n    if (isServer) {\n      context!.setStatusCode(200);\n    }\n  });\n\n  return null;\n}\n", "import { createRouteAction, createRouteData, createRouteMultiAction } from \"../data\";\nexport { ServerError } from \"../data\";\nexport const createServerData$ = createRouteData;\nexport const createServerAction$ = createRouteAction;\nexport const createServerMultiAction$ = createRouteMultiAction;\n", "export { server$ as default } from \"./server-functions/browser\";\nexport * from \"./shared\";\n\nexport const isServerFunctionRequest = () => {\n  throw new Error(\"isServerFunctionRequest is not supported on the browser\");\n};\n\n\n"],
  "mappings": "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",
  "names": ["Outlet", "useSearchParams", "handleResponse", "fetcher", "useSearchParams"]
}
